# Chapter 5 오차역전파법
앞 장에서 설명한 신경망 학습에서 신경망의 가중치 매개변수의 기울기(정확히는 가중치 매개변수에 대한 손실 함수의 기울기)는 수치 미분을 사용해 구했다. 수치 미분은 단순하고 구현하기도 쉽지만 계산 시간이 오래 걸린다는 게 단점이다. 이번 장에서는 가중치 매개변수의 기울기를 효율적으로 계산하는 **오차역전파법** *(backpropagation)* 을 배워보자.  

## 5.1 계산 그래프
**계산 그래프**는 계산 과정을 그 래프로 나타낸 것이다. 여기에서의 그래프는 우리가 잘 아는 그래프 자료구조로, 복수의 노드(node)와 에지(edge)로 표현된다(노드 사이의 직선을 '에지'라고 한다).  

### 5.1.1 계산 그래프로 풀다
간단한 문제를 계산 그래프를 사용해 풀어보자.  
```
문제 1 : 현빈 군은 슈퍼에서 1개에 100원인 사과를 2개 샀다. 이때 지불 금액을 구하라. 단, 소비세가 10% 부과된다.
```
계산 그래프는 계산 과정을 노드와 화살표로 표현한다. 노드는 원(O)으로 표기하고 원 안에 연산 내용을 적는다. 또, 계산 결과를 화살표 위에 적어 각 노드의 계산 결과가 왼쪽에서 오른쪽으로 전해지게 한다. 문제 1을 계산 그래프로 풀면 [그림 5-1]처럼 된다.  

![5-1](../Images/5_1.png)  
[그림 5-1] 계산 그래프로 풀어본 문제 1의 답  

[그림 5-1]과 같이 처음에 사과의 100원이 'X2' 노드로 흐르고, 200원이 되어 다음 노드로 전달된다. 이제 200원이 'X1.1' 노드를 거쳐 220원이된다. 따라서 이 계산 그래프에 따르면 최종 답은 220원이 된다.  

또한, [그림 5-1]에서는 'X2'와 'X1.1'을 각각 하나의 연산으로 취급해 원 안에 표기했지만, 곱셈인 'X'만을 연산으로 생각할 수도 있다. 이렇게 하면 [그림 5-2]처럼 '2'와 '1.1'은 각각 '사과의 개수'와 '소비세' 변수가 되어 원 밖에 표기하게 된다.  

![5-2](../Images/5_2.png)  
[그림 5-2] 계산 그래프로 풀어본 문제 1의 답 : '사과의 개수'와 '소비세'를 변수로 취급해 원 밖에 표기  

```
문제 2 : 현빈 군은 슈퍼에서 사과를 2개, 귤을 3개 샀다. 사과는 1개에 100원, 귤은 1개 150원이다. 소비세가 10%일 때 지불 금액을 구하라. 
```
문제 2도 문제 1과 같이 계산 그래프로 풀어보자.   

![5-3](../Images/5_3.png)  
[그림 5-3] 계산 그래프로 풀어본 문제 2의 답  

이 문제에는 덧셈 노드인 '+'가 새로 등장하여 사과와 귤의 금액을 합산한다. 계산 그래프는 왼쪽에서 오른쪽으로 계산을 진행한다. 문제 2의 답은 715원이다.  

지금까지 살펴본 것처럼 계산 그래프를 이용한 문제풀이는 다음 흐름으로 진행한다.  
1. 계산 그래프를 구성한다.
2. 그래프에서 계산을 왼쪽으로 오른쪽으로 진행( **순전파** *(forward propagation)* )  

2번째 계산을 순전파라고 하는데, 순전파는 계산 그래프의 출발점부터 종착점으로의 전파다. **역전파** *(backward propagation)* 는 오른쪽에서 왼쪽으로 진행한다. 역전파는 이후에 미분을 계산할 때 중요한 역할을 한다.  


### 5.1.2 국소적 계산
계산 그래프의 특징은 '국소적 계산'을 전파함으로써 최종 결과를 얻는다는 점에 있다. 국소적이란 '자신과 직접 관계된 작은 범위'라는 뜻이다. 국소적 계산은 결국 전체에서 어떤 일이 벌어지든 상관없이 자신과 관계된 정보만으로 결과를 출력할 수 있다.  

국소적 계산을 구체적인 예를 들어 설명하자면, 슈퍼마켓에서 사과 2개를 포함한 여러 식품을 구입하는 경우를 생각해보자. [그림 5-4]와 같은 계산 그래프로 나타낼 수 있다.  

![5-4](../Images/5_4.png)  
[그림 5-4] 사과 2개를 포함해 여러 식품을 구입하는 예  

[그림 5-4]에서는 여러 식품을 구입하여 총 금액이 4,000원이 되었다. 여기에서 핵심은 각 노드에서의 계산은 국소적 계산이라는 점이다. 가령 사과와 그 외의 물품 값을 더하는 계산(4,000 + 200 -> 4,200)은 4,000이라는 숫자가 어떻게 계산되었느냐와는 상관없이, 단지 두 숫자를 더하면 된다는 뜻이다. 각 노드는 자신과 관련한 계산(이 예에서는 입력된 두 숫자의 덧셈) 외에는 아무것도 신경 쓸 게 없다.  

이처럼 계산 그래프는 국소적 계산에 집중한다. 전체 계산이 복잡하더라도 각 단계에서 하는 일은 해당 노드의 '국소적 계산'이다. 국소적인 계산은 '국소적 계산'이다.  


### 5.1.3 왜 계산 그래프로 푸는가?
계산 그래프의 이점은 방금 설명한 `국소적 계산`과 `중간 계산 결과를 모두 보관`한다는 점이다. 예를 들어 사과 2개까지 계산했을 때의 금액은 200원, 소비세를 더하기 전의 금액은 650원인 식이다. 실제 계산 그래프를 사용하는 가장 큰 이유는 `역전파를 통해 '미분'을 효율적으로 계산할 수 있다는 점`에 있다.  

문제 1은 사과를 2개 사서 소비세를 포함한 최종 금액을 구하는 것이다. 여기서 사과 가격이 오르면 최종 금액에 어떤 영향을 끼치는지 알고 싶을 때 이는 `사과 가격에 대한 지불 금액의 미분`을 구하는 문제에 해당한다. 기호로 나타내면 사과 값을 x, 지불 금액을 L이라 했을 때 ∂L/∂x을 구하는 것이다. 이 미분 값은 사과 값이 '아주 조금' 올랐을 때 지불 금액이 얼마나 증가하느냐를 표시한 것이다.  

'사과 가격에 대한 지불 금액의 미분'같은 값은 계산 그래프에서 역전파를 하면 구할 수 있다. 먼저 결과만을 나타내면 [그림 5-5]처럼 계산 그래프 상의 역전파에 의해서 미분을 구할 수 있다.  

![5-5](../Images/5_5.png)  
[그림 5-5] 역전파에 의한 미분 값의 전달   

[그림 5-5]와 같이 역전파는 순전파와는 반대 방향의 화살표(굵은 선)로 그린다. 이 전파는 '국소적 미분'을 전달하고 그 미분 값은 화살표의 아래에 적는다. 이 결과로부터 `사과 가격에 대한 지불 금액의 미분` 값은 2.2라 할 수 있다. 사과가 1원 오르면 최종 금액은 2.2원 오른다는 뜻(정확히는 사과 값이 아주 조금 오르면 최종 금액은 그 아주 작은 값의 2.2배만큼 오른다는 뜻)이다.  

`소비세에 대한 지불 금액의 미분`이나 `사과 개수에 대한 지불 금액의 미분`도 같은 순서로 구할 수 있다. 이처럼 계산 그래프의 이점은 순전파와 역전파를 활용해서 각 변수의 미분을 효율적으로 구할 수 있다는 것이다.  

## 5.2 연쇄법칙
`국소적 미분`을 전달하는 원리는 **연쇄법칙**에 따른 것이고, 그것은 계산 그래프 상의 역전파와 같다.  

### 5.2.1 계산 그래프의 역전파
y = f(x) 계산의 역전파는 [그림 5-6]로 그렸다.  

![5-6](../Images/5_6.png)  
[그림 5-6] 계산 그래프의 역전파 : 순방향과는 반대 방향으로 국소적 미분을 곱한다.   

역전파의 계산 절차는 신호 D에 노드의 국소적 미분(∂y/∂x)을 곱한 후 다음 노드로 전달하는 것이다. 여기에서 말하는 국소적 미분은 순전파 때의 y=f(x) 계산의 미분을 구한다는 것이며, 이는 x에 대한 y의 미분(∂y/∂x)을 구한다는 뜻이다. 가령 y=f(x)=x^2이라면 ∂y/∂x=2x가 된다. 그리고 이 국소적인 미분을 상류에서 전달된 값(이 예에서는 E)에 곱해 앞쪽 노드로 전달하는 것이다.  

이것이 역전파의 계산 순서인데, 이러한 방식을 따르면 목표로 하는 미분 값을 효율적으로 구할 수 있다는 것이 이 전파의 핵심이다. 왜 그런 일이 가능한가는 연쇄법칙의 원리로 설명할 수 있다.  

### 5.2.2 연쇄법칙이란?
연쇄법칙을 설명하려면 우선 합성 함수 이야기부터 시작해야 한다. **합성 함수**란 여러 함수로 구성된 함수이다. 예를 들어 z=(x+y)^2이라는 식은 [식 5.1]처럼 두 개의 식으로 구성된다.  

![5.1](../Images/e_5.1.png)  
[식 5.1]  

연쇄법칙은 합성 함수의 미분에 대한 성질이며, 다음과 같이 정의된다.  

```
합성 함수의 미분은 합성 함수를 구성하는 각 함수의 미분의 곱으로 나타낼 수 있다.
```
이것이 연쇄법칙의 원리이다. [식 5.1]을 예로 설명하면, ∂z/∂x(x에 대한 z의 미분)은 ∂z/∂t(t에 대한 z의 미분)과 ∂t/∂x(x에 대한 t의 미분)의 곱으로 나타낼 수 있다. 수식으로는 [식 5.2]처럼 쓸 수 있다.  

![5.2](../Images/e_5.1.png)  
[식 5.2]  

[식 5.2]는 ∂t를 서로 지울 수 있다. 연쇄범칙을 써서 [식 5.2]의 미분 ∂z/∂x를 구해보자. 가장 먼저 [식 5.1]의 국소적 미분(편미분)을 구하자.  


![5.3](../Images/e_5.3.png)  
[식 5.3]  

[식 5.3]과 같이 ∂z/∂t는 2t이고, ∂t/∂x는 1이다. 이는 미분 공식에서 해석적으로 구한 결과다, 그리고 최종적으로 구하고 싶은 ∂z/∂x는 [식 5.3]에서 구한 두 미분을 곱해 계산한다.  

![5.4](../Images/e_5.4.png)  
[식 5.4]  


### 5.2.3 연쇄법칙과 계산 그래프
[식 5.4]의 연쇄법칙 계산을 계산 그래프로 나타내보자. 2제곱 계산을 `**2` 노드로 나타내면 [그림 5-7]처럼 그릴 수 있다.  

![5-7](../Images/5_7.png)  
[그림 5-7] [식 5.4]의 계산 그래프 : 순전파와는 반대 방향으로 국소적 미분을 곱하여 전달  

계산 그래프의 역전파는 오른쪽에서 왼쪽으로 신호를 전파한다. 역전파의 계산 절차에서는 노드로 들어온 입력 신호에 그 노드의 국소적 미분(편미분)을 곱한 후 다음 노드로 전달한다. 예를 들어 `**2` 노드에서의 역전파를 보자. 입력은 ∂z/∂z이며, 이에 국소적 미분은 ∂z/∂t(순전파 시에는 입력이 t이고 출력이 z이므로 이 노드에서 국소적 미분은 ∂z/∂t)를 곱하고 다음 노드로 넘긴다.  

[그림 5-7]에서 주목할 것은 맨 왼쪽 역전파다. 이 게산은 연쇄 법칙에 따르면 `x에 대한 z의 미분`이 된다. 즉, 역전파가 하는 일은 연쇄법칙의 원리와 같다.  

[그림 5-7]에서 [식 5.3]의 결과를 대입하면 [그림 5-8]이 되며, ∂z/∂x는 2(x+y)임을 구할 수 있다.  

![5-8](../Images/5_8.png)  
[그림 5-8] 계산 그래프의 역전파 결과에 따르면 ∂z/∂x는 2(x+y)가 된다.  


## 5.3 역전파
### 5.3.1 덧셈 노드의 역전파
여기에서는 z = x + y라는 식을 대상으로 그 역전파를 살펴보자. 우선 z = x + y의 미분은 다음과 같이 해석적으로 계산할 수 있다.  

![5.5](../Images/e_5.5.png)  
[식 5.5]  

[식 5.5]에서와 같이 ∂z/∂x와 ∂z/∂y는 모두 1이 된다. 이를 계산 그래프로는 [그림 5-9]처럼 그릴 수 있다.  

![5-9](../Images/5_9.png)  
[그림 5-9] 덧셈 노드의 역전파 : 왼쪽이 순전파, 오른쪽이 역전파다. 덧셈 노드의 역전파는 입력 값을 그대로 흘려보낸다.  

[그림 5-9]와 같이 역전파 때는 상류에서 전해진 미분(이 예에서는 ∂L/∂z)에 1을 곱하여 하류로 흘린다. 즉, 덧셈 노드의 역전파는 1을 곱하기만 할 뿐이므로 입력된 값을 그대로 다음 노드로 보내게 된다.  

이 예에서는 상류에서 전해진 미분 값을 ∂L/∂z이라 했는데, 이는 [그림 5-10]과 같이 최종적으로 L이라는 값을 출력하는 큰 계산 그래프를 가정하기 때문이다. z = x + y 계산은 그 큰 계산 그래프의 중간 어딘가에 존재하고, 상류로부터 ∂L/∂z 값이 전해진 것이다. 그리고 다시 하류로는 ∂L/∂x과 ∂L/∂y 값을 전달하는 것이다.  

![5-10](../Images/5_10.png)  
[그림 5-10] 최종 출력으로 가는 계산의 중간에 덧셈 노드 존재  

구체적인 예를 살펴보자. 가령 '10 + 5 = 15'라는 계산이 있고, 상류에서 1.3이라는 값이 흘러온다. 이를 계산 그래프로 그리면 [그림 5-11]처럼 된다.  

![5-11](../Images/5_11.png)  
[그림 5-11] 덧셈 노드 역전파의 구체적인 예  

덧셈 노드 역전파는 입력 신호를 다음 노드로 출력할 뿐이므로 [그림 5-11]처럼 1.3을 그대로 다음 노드로 전달한다.  


### 5.3.2 곱셈 노드의 역전파
z = xy라는 식을 생각해보자. 이 식의 미분은 다음과 같다.  

![5.6](../Images/e_5.6.png)  
[식 5.6]  

[식 5.6]에서 계산 그래프는 다음과 같이 그릴 수 있다.  

![5-12](../Images/5_12.png)  
[그림 5-12] 곱셈 노드의 역전파 : 왼쪽으 순전파, 오른쪽이 역전파  

곱셈 노드 역전파는 상류의 값에 순전파 때의 입력 신호들을 '서로 바꾼 값'을 곱해서 하류로 보낸다. 서로 바꾼 값이란 [그림 5-12]처럼 순전파 때 x였다면 역전파에서는 y, 순전파 때 y였다면 역전파에서는 x로 바꾼다는 의미이다.  

`10 x 5 = 50`이라는 계산이 있고, 역전파 때 상류에서 1.3 값이 흘러온다고 한다. 이를 계산 그래프로 그리면 [그림 5-13]처럼 된다.  

![5-13](../Images/5_13.png)  
[그림 5-13] 곱셈 노드 역전파의 구체적인 예  

곱셈의 역전파에서는 입력 신호를 바꾼 값을 곱하여 하나는 1.3 x 5 = 6.5, 다른 하나는 1.3 x 10 = 13이 된다. 덧셈의 역전파는 상류의 값을 그대로 흘려보내서 순방향 입력 신호의 값은 필요하지 않았다. 하지만 곱셈의 역전파는 순방향 입력 신호의 값이 필요한다. 그래서 곱셈 노드를 구현할 때는 순전파의 입력 신호를 변수에 저장해둔다.  


### 5.3.3 사과 쇼핑의 예
이 문제에서는 사과의 가격, 사과의 개수, 소비세라는 세 변수 각각이 최종 금액에 어떻게 영향을 주느냐를 풀고자 한다. 이는 `사과 가격에 대한 지불 금액의 미분`, `사과 개수에 대한 지불 금액의 미분`, `소비세에 대한 지불 금액의 미분`을 구하는 것에 해당한다. 이를 계산 그래프의 역전파를 사용해서 풀면 [그림 5-14]처럼 된다.  

![5-14](../Images/5_14.png)  
[그림 5-14] 사과 쇼핑의 역전파 예  

지금까지 설명한 바와 같이 곱셈 노드의 역전파에서는 입력 신호를 서로 바꿔서 하류로 흘린다. [그림 5-14]의 결과를 보면 사과 가격의 미분은 2.2, 사과 개수의 미분은 110, 소비세의 미분은 200이다. 이는 소비세와 사과 가격이 같은 양만큼 오르면 최종 금액에는 소비세가 200의 크기로, 사과 가격이 2.2 크기로 영향을 준다고 해석할 수 있다. 단, 이 예에서는 소비세와 사과 가격은 단위가 다르니 주의해야 한다(소비세 1은 100%, 사과 가격 1은 1원).  

정리할 겸, 마지막으로 '사과와 귤 쇼핑'의 역전파를 풀어보자. [그림 5-15]의 빈 상자에 적당한 숫자를 넣어 각 변수의 미분을 구하라.  

![5-15](../Images/5_15.png)  
[그림 5-15] 사과와 귤 쇼핑의 역전파 예 : 빈 상자 안에 적절한 숫자를 넣어 역전파를 완성하라.    


## 5.4 단순한 계층 구현하기
'사과 쇼핑' 예를 파이썬으로 구현해보자. 여기에서는 계산 그래프의 곱셈 노드를 'MulLayer', 덧셈 노드를 'AddLayer'라는 이름으로 구현한다.  
```
다음 절에서는 신경망을 구성하는 '계층' 각각을 하나의 클래스로 구현한다. 여기에서 말하는 '계층'이란 신경망의 기능 단위이다. 예를 들어 시그모이드 함수를 위한 Sigmoid, 행렬 내적을 위한 Affine 등의 기능을 계층 단위로 구현한다. 그래서 이번 절에서도 곱셈 노드와 덧셈 노드를 '계층' 단위로 구현한다. 
```

### 5.4.1 곱셈 계층
모든 계층은 forward()와 backward()라는 공통의 메소드(인터페이스)를 갖도록 구현할 것이다. forward()는 순전파, backward()은 역전파를 처리한다. 곱셈 계층은 MulLayer라는 이름의 클래스로 다음과 같이 구현할 수 있다.  

```python
class MulLayer :
    def __init__(self) :
        self.x = None
        self.y = None
    
    def forward(self, x, y) :
        self.x = x
        self.y = y
        out = x * y

        return out
    
    def backward(self, dout) :
        dx = dout * self.y  # x와 y를 바꾼다.
        dy = dout * self.x

        return dx, dy
```
__init__()에서는 인스턴스 변수인 x, y를 초기화한다. 이 두 변수는 순전파 시의 입력 값을 유지하기 위해 사용한다. forward()에서는 x와 y를 인수로 받고 두 값을 곱해서 반환한다. 반면 backward()에서는 상류에서 넘어온 미분(dout)에 순전파 때의 값을 '서로 바꿔' 곱한 후 하류로 흘린다.  

이 MulLayer를 사용해서 앞으로 본 '사과 쇼핑'을 구현해보자. 앞 절에서는 계산 그래프의 순전파와 역전파를 써서 [그림 5-16]과 같이 계산할 수 있었다.  

![5-16](../Images/5_16.png)  
[그림 5-16] 사과 2개 구입  

MulLayer를 사용하여 [그림 5-16]의 순전파를 다음과 같이 구현할 수 있다.  

```python
apple = 100
apple_num = 2
tax = 1.1

# 계층들
mul_apple_layer = MulLayer()
mul_tax_layer = MulLayer()

# 순전파
apple_price = mul_apple_layer.forward(apple, apple_num)
price = mul_tax_layer.forward(apple_price, tax)

print(price)    # 220.00000000000003
```

각 변수에 대한 미분은 backward()에서 구할 수 있다.  

```python 
# 역전파
dprice = 1
dapple_price, dtax = mul_tax_layer.backward(dprice)
dapple, dapple_num = mul_apple_layer.backward(dapple_price)

print(dapple, dapple_num, dtax)   # 2.2 110.00000000000001 200
```
backward() 호출 순서는 forward() 때와는 반대다. 또, backward()가 받는 인수는 '순전파의 출력에 대한 미분'임에 주의해야 한다. 가령 mul_apple_layer라는 곱셈 계층은 순전파 때는 apple_price를 출력하지만, 역전파 때는 apple_price의 미분 값인 dprice_price를 인수로 받는다. 마지막으로, 이 코드를 실행한 결과는 [그림 5-16]의 결과와 일치한다.  


### 5.4.2 덧셈 계층
```python 
class AddLayer :
    def __init__(self) :
        pass

    def forward(self, x, y) :
        out = x + y
        return out

    def backward(self, dout) :
        dx = dout * 1
        dy = dout * 1
        return dx, dy
```
덧셈 계층에서는 초기화가 필요 없으니 __init__()에서는 아무 일도 하지 않는다. 덧셈 계층의 forward()에서는 입력받은 두 인수 x, y를 더해서 반환한다. backward()에서는 상류에서 내려온 미분(dout)을 그대로 하류로 흘릴 뿐이다.  

이 덧셈 계층과 곱셈 계층을 사용하여 사과 2개와 귤 3개를 사는 [그림 5-17]의 상황을 구현해보자.  

![5-17](../Images/5_17.png)  
[그림 5-17] 사과 2개와 귤 3개 구입  

```python 
apple = 100
apple_num = 2
orange = 150
orange_num = 3
tax = 1.1

# layer
mul_apple_layer = MulLayer()
mul_orange_layer = MulLayer()
add_apple_orange_layer = AddLayer()
mul_tax_layer = MulLayer()

# forward
apple_price = mul_apple_layer.forward(apple, apple_num)  # (1)
orange_price = mul_orange_layer.forward(orange, orange_num)  # (2)
all_price = add_apple_orange_layer.forward(apple_price, orange_price)  # (3)
price = mul_tax_layer.forward(all_price, tax)  # (4)

# backward
dprice = 1
dall_price, dtax = mul_tax_layer.backward(dprice)  # (4)
dapple_price, dorange_price = add_apple_orange_layer.backward(dall_price)  # (3)
dorange, dorange_num = mul_orange_layer.backward(dorange_price)  # (2)
dapple, dapple_num = mul_apple_layer.backward(dapple_price)  # (1)

print(price)  # 715
print(dapple_num, dapple, dorange, dorange_num, dtax)   # 110 2.2 3.3 165 650
```


## 5.5 활성화 함수 계층 구현하기
계산 그래프를 신경망에 적용하는데 여기에서는 신경망을 구성하는 층(계층) 각각을 클래스 하나로 구현한다. 우선은 활성화 함수인 ReLU와 Sigmoid 계층을 구현해보자.  

### 5.5.1 ReLU 계층
활성화 함수로 사용되는 ReLU의 수식은 다음과 같다.  

![5.7](../Images/e_5.7.png)  
[식 5.7]  

[식 5.7]에서 x에 대한 y의 미분은 [식 5.8]처럼 구한다.  

![5.8](../Images/e_5.8.png)  
[식 5.8]  

[식 5.8]에서와 같이 순전파 때의 입력인 x가 0보다 크면 역전파는 상류의 값을 그대로 하류로 흘린다. 반면, 순전파 때 x가 0 이하면 역전파 때는 하류로 신호를 보내지 않는다(0 보냄). 계산 그래프로는 [그림 5-18]처럼 그릴 수 있다.  

![5-18](../Images/5_18.png)  
[그림 5-18] ReLU 계층의 계산 그래프  

신경망 계층의 forward()와 backward() 함수는 넘파이 배열을 인수로 받는다고 가정하고 ReLU 계층을 구현해보자.  

```python
class Relu:
    def __init__(self):
        self.mask = None

    def forward(self, x):
        self.mask = (x <= 0)
        out = x.copy()
        out[self.mask] = 0

        return out

    def backward(self, dout):
        dout[self.mask] = 0
        dx = dout

        return dx
```
Relu 클래스는 mask라는 인스턴스 변수를 가진다. mask는 True/False로 구성된 넘파이 배열로, 순전파의 입력인 x의 원소 값이 0 이하인 인덱스는 True, 그 외(0보다 큰 원소)는 False로 유지한다.  

[그림 5-18]과 같이 순전파 때의 입력 값이 0 이하면 역전파 떄의 값은 0이 돼야 한다. 그래서 역전파 때는 순전파 때의 입력 값이 0 이하면 역전파 때의 값은 0이 돼야 한다. 그래서 역전파 때는 순전파 때 만들어둔 mask를 써서 mask의 원소가 True인 곳에는 상류에서 전파된 dout을 0으로 설정한다.  
```
ReLU 계층은 전기 회로의 '스위치'에 비유할 수 있다. 순전파 때 전류가 흐르고 있으면 스위치를 ON으로 하고, 흐르지 않으면 OFF로 한다. 역전파 때는 스위치가 ON이라면 전류가 그대로 흐르고, OFF면 더 이상 흐르지 않는다. 
```

### 5.5.2 Sigmoid 계층 
시그모이드 함수는 다음 식을 의미하는 함수다.  

![5.9](../Images/e_5.9.png)  
[식 5.9]  

[식 5.9]를 계산 그래프로 그리면 [그림 5-19]처럼 된다.  

![5-19](../Images/5_19.png)  
[그림 5-19] Sigmoid 계층의 계산 그래프(순전파)  

[그림 5-19]에는 'X'와 '+' 노드 말고도 'exp'와 '/' 노드가 새롭게 등장했다. 'exp' 노드는 y=exp(x) 계산을 수행하고 '/' 노드는 y = 1/x 계산을 수행한다.  

[그림 5-19] 역전파의 흐름을 오른쪽에서 왼쪽으로 한 단계씩 짚어보자.  

### 1단계
'/' 노드, 즉 y = 1/x을 미분하면 다음 식이 된다.  

![5.10](../Images/e_5.10.png)  
[식 5.10]  

[식 5.10]에 따르면 역전파 때는 상류에서 흘러온 값에 -y^2(순전파의 출력을 제곱한 후 마이너스를 붙인 값)을 곱해서 하류로 전달한다. 계산 그래프에서는 다음과 같다.  

![5-19](../Images/5_19(1).png)  
  
### 2단계
'+' 노드는 사율의 값을 여과 없이 하류로 보낸다. 계산 그래프에서는 다음과 같다.  

![5-19](../Images/5_19(2).png)  
  

### 3단계
'exp' 노드는 y = exp(x) 연산을 수행하며, 그 미분은 다음과 같다.  

![5.11](../Images/e_5.11.png)  
[식 5.11]  

계산 그래프에서는 상류의 값에 순전파 때의 출력(이 예에서는 exp(-x))을 곱해 하류로 전파한다.  

![5-19](../Images/5_19(3).png)  

### 4단계
'X' 노드는 순전파 때의 값을 '서로 바꿔' 곱한다. 이 예에서는 -1을 곱하면 된다.  

![5-20](../Images/5_20.png)  
[그림 5-20] Sigmoid 계층의 계산 그래프  

역전파의 최종 출력 값은 순전파의 입력 x와 출력 y만으로 계산할 수 있다. [그림 5-20]의 계산 그래프의 중간 과정을 모두 묶어 [그림 5-21]처럼 단순한 `sigmoid` 노드 하나로 대체할 수 있다.  

![5-21](../Images/5_21.png)  
[그림 5-21] Sigmoid 계층의 계산 그래프(간소화 버전)  

출력값을 다음과 같이 정리해서 쓸 수 있다.  

![5.12](../Images/e_5.12.png)  
[식 5.12]  

이처럼 Sigmoid 계층의 역전파는 순전파의 출력(y)만으로 계산할 수 있다.  

![5-22](../Images/5_22.png)  
[그림 5-22] Sigmoid 계층의 계산 그래프 : 순전파의 출력 y만으로 역전파 계산 가능  

파이썬으로 Sigmoid 계층을 구현해보자.  

```python 
class Sigmoid:
    def __init__(self):
        self.out = None

    def forward(self, x):
        out = 1 / (1 + np.exp(-x))
        self.out = out

        return out

    def backward(self, dout):
        dx = dout * (1.0 - self.out) * self.out

        return dx
```
순전파의 출력을 인스턴스 변수 out에 보관했다가, 역전파 계산 때 그 값을 사용한다.  


## 5.6 Affine/Softmax 계층 구현하기
### 5.6.1 Affine 계층
신경망의 순전파에서는 가중치 신호의 총합을 계산하기 때문에 행렬의 내적(넘파이에서는 np.dot())을 사용했다.  

![5-23](../Images/5_23.png)  
[그림 5-23] 행렬의 내적에서는 대응하는 차원의 원소 수를 일치시킨다.  

```
신경망의 순전파 때 수행하는 동안 행렬의 내적은 기하학에서는 어파인 변환(Affine transformation)이라고 한다. 그래서 이 책에서는 어파인 변환을 수행하는 처리를 'Affine 계층'이라는 이름으로 구현한다.   
```

행렬의 내적과 편향의 합을 계산 그래프로 그려보자. 내적을 계산하는 노드를 'dot'이라 하면 np.dot(X, W) + B 계산은 [그림 5-24]처럼 그려진다. 또한, 각 변수의 이름 위에 그 변수의 이이름도 ㄸ]



















